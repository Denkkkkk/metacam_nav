#map_type: voxel
map_type: costmap

# 圆形机器人
robot_radius: 0.20
# 矩形机器人
# footprint: [[0.23,0.19],[0.25,0],[0.23,-0.19],[-0.23, -0.19],[-0.23,0.19]]

# 是否启用恢复行为，如果启用，会在规定时间内没有规划出路径时，会执行恢复行为
recovery_behavior_enabled: true
transform_tolerance: 1.0
controller_frequency: 5

#静态地图层
static_layer:
 enabled: true

#动态障碍地图层
obstacle_layer:
  enabled: true
  combination_method: 1        # 只能设置为0或1，用来更新地图上的代价值，一般设置为1;
  #如果设置为false，那么地图上代价值就只分为致命碰撞和自由区域两种。
  #如果设置为true，那么就分为致命碰撞，自由区域和未知区域三种。
  #若为true,可以把一些未探索的未知区域也来参与到路径规划。
  track_unknown_space: false
  origin_z: 0.0
  z_voxels: 20
  z_resolution: 0.1
  unknown_cost_value: 0
  unknown_threshold: 8
  mark_threshold: 0
  publish_voxel_map: false

  #动态障碍物检测范围
  #只有靠近到该范围内的动态障碍物才会更新
  obstacle_range: 2.5
  #在机器人移动过程中，实时清除代价地图上的障碍物的最大范围，更新可自由移动的空间数据。
  raytrace_range: 20.0 
  #inf_is_valid: true
  max_obstacle_height: 0.40       #超过该高度的障碍物，并不进行检测
  min_obstacle_height: 0.02       #低于该高度的障碍物，并不进行检测
  controller_frequency: 2         #控制器更新频率，也就是规划频率    

  #这里可以用逗号形式来区分开很多个传感器，例如激光雷达，碰撞传感器，超声波传感器等
  #要与下面的laser_scan_sensor:对应
  observation_sources: laser_scan_sensor      
  laser_scan_sensor: {
    sensor_frame: lidar,  
    observation_persistence: 0.0, 
    max_obstacle_height: 5,        #超过该范围的障碍物，并不进行检测
    min_obstacle_height: 0.4,      #低于该范围的障碍物，并不进行检测
    data_type: LaserScan, 
    topic: /scan,                  
    marking: true,                 #是否可以使用该传感器来标记障碍物;
    clearing: true                 #是否可以使用该传感器来清除障碍物;
    }                

#障碍膨胀层
inflation_layer:
  enabled: true
  #代价地图中到障碍物距离在内切圆半径到膨胀半径之间的所有cell可以使用如下公式来计算膨胀代价：
  # exp(-1.0 * cost_scaling_factor * (distance_from_obstacle – inscribed_radius)) * 
  # (costmap_2d::INSCRIBED_INFLATED_OBSTACLE – 1),
  #公式中costmap_2d::INSCRIBED_INFLATED_OBSTACLE目前指定为254，
  #注意： 由于在公式中cost_scaling_factor被乘了一个负数，所以增大比例因子反而会降低代价
  cost_scaling_factor: 5.0        #膨胀过程中应用到代价值的比例因子
  inflation_radius: 0.25          #膨胀半径，膨胀层会把障碍物代价膨胀直到该半径为止，一般将该值设置为机器人底盘的半径大小。

